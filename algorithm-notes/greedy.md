# Greedy 알고리즘

지금 가장 최적인 답을 '근시안적'으로 택하는 알고리즘.
-> 관찰을 통해 탐색 범위를 줄이는 것이 핵심이다.

## 이상적인 풀이 흐름

1. 그리디 냄새가 나면 관찰을 통해 탐색 범위를 줄이는 알고리즘을 생각한다.
2. 떠올린 알고리즘이 최적해를 도출한다는 수학적인 증명을 수행한다.
3. 증명이 완료되면, 구현을 통해 풀이를 완료한다.

하지만 현실적으로 코딩테스트에서는 가설을 세우고 증명하는 과정을 거치기엔 시간이 빠듯하기 때문에, 잘못된 가설을 세우고 감에 의존해서 풀다가 구현 실수인지 알고리즘 설계 실수인지 파악하지 못한 채 풀이에 실패하는 경우가 종종있다.

### [실전 전략]

조건 : 해당 문제가 이미 풀어본 문제와 매우 유사하거나, 간단하다는 확신이 든다.

- 나의 그리디 알고리즘을 만들고, 100% 확신한다 || 100% 확신은 없지만, 그럴싸한 풀이로 진행한다.

- 풀이에 실패하면, 미련없이 다른 문제를 풀어야한다.

---

그리디의 직관을 검증하기 위해서는 수학적으로 증명하는 과정이 필요하다.

예제 1)
가치를 가진 일련의 동전 수열이 주어지고 개별 동전이 무수히 많은 경우를 생각하자.
이 때 주어진 동전들을 이용하여 특정 값을 충족하는 최소 동전 개수를 구하고자 할 때, 가치가 큰 동전들부터 사용하는 논리를 세우면 문제를 풀 수 있을 것처럼 보인다.

1. 보조 정리
   동전을 최소로 소모하면서 물건값을 지불하려 10/100원 동전은 4개 이하, 50원 동전은 1개 이하로 사용해야 한다.

2. 귀류법으로 증명
   가정 : 각 10/100원 동전을 5개 이상 사용해야 최소 개수를 충족한다.
   -> 5개 마다 50/500원으로 대체할 수 있다.
   -> 50원 동전은 2개 마다 100원으로 대체가 된다.
   근거에 의해 오히려 동전 개수가 줄었으므로, 가정은 거짓이다.
   따라서 보조 정리는 참이 된다.

그리디의 수학적 증명 과정이 중요한 이유는 반례를 통해 확인할 수 있다.
예를 들어 (1원/9원/10원) 동전을 가지고 18원을 만드는 경우를 생각해본다.
이 경우, 10원과 9원 간의 배수 관계가 성립되지 않으므로 앞서 세운 보조 정리가 거짓이 된다.
결국 정답은 2개(9x2)이지만 그리디 알고리즘은 9( 10x1 + 1x8 )개를 내뱉는다.

---

예제 2 - boj 1931 회의실 배정 문제)

풀이 자체는 회의 리스트가 끝나는 시간이 빠른 순으로 정렬되어 있을 때, 선택 가능한 회의 중 끝 시간이 가장 짧은 걸 선택하면된다.

그렇다면 이것이 수학적으로 옳다는 것을 증명해보자.

- 명제
  현재 시각 t 에서, 시작 시간이 t 이상인 모든 회의 중 가장 먼저 끝나는 회의를 선택하는 것이 최적해이다.
- 귀류법 증명
  가설 ) 시간이 늦게 끝나는 회의를 선택해도 최적해에 도달할 수 있다.
  그렇다면 두 회의를 가정한다.
  - 회의 A - [t+1, t+2]
  - 회의 B - [t+3, t+4]
    가설에 따라 회의 B를 선택한다.
    하지만, 회의 B를 선택해도 회의 A를 선택할 수 있으므로 이는 최적해가 아니다.
    증명 완료.

---

출처 : [바킹독의 실전 알고리즘 0x11강 그리디](https://www.youtube.com/watch?v=De0Qg-2O80c&list=PLtqbFd2VIQv4O6D6l9HcD732hdrnYb6CY&index=18)
